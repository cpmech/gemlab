
    use super::Find;
    use crate::mesh::{all_edges_2d, all_faces_3d, allocate_shapes, At, Extract, Features, Samples};
    use crate::util::SQRT_2;
    use crate::StrError;
    use std::collections::HashSet;

    #[allow(dead_code)]
    fn plot_grid_two_quads_horizontal(find: &Find) -> Result<(), StrError> {
        let mut plot = find.grid.plot()?;
        plot.set_equal_axes(true).set_figure_size_points(800.0, 400.0);
        plot.save("/tmp/gemlab/find_with_two_quads_horizontal.svg")
    }

    #[allow(dead_code)]
    fn plot_grid_two_cubes_vertical(find: &Find) -> Result<(), StrError> {
        let mut plot = find.grid.plot()?;
        plot.set_equal_axes(true).set_figure_size_points(2048.0, 2048.0);
        plot.save("/tmp/gemlab/find_with_two_cubes_vertical.svg")
    }

    #[test]
    fn new_works() -> Result<(), StrError> {
        let mesh = Samples::two_quads_horizontal();
        let shapes = allocate_shapes(&mesh)?;
        let edges = all_edges_2d(&mesh, &shapes)?;
        let boundary = Features::extract(&mesh, &shapes, Some(&edges), None, Extract::Boundary)?;
        let find = Find::new(&mesh, &boundary)?;
        // plot_grid_two_quads_horizontal(&find)?;
        assert_eq!(
            format!("{}", find.grid),
            "0: [0]\n\
             9: [1]\n\
             10: [1]\n\
             19: [4]\n\
             180: [3]\n\
             189: [2]\n\
             190: [2]\n\
             199: [5]\n\
             ids = [0, 1, 2, 3, 4, 5]\n\
             nitem = 6\n\
             ncontainer = 8\n\
             ndiv = [20, 10]\n"
        );
        Ok(())
    }

    #[test]
    fn find_points_fails_on_wrong_input() -> Result<(), StrError> {
        // 2d
        let mesh = Samples::two_quads_horizontal();
        let shapes = allocate_shapes(&mesh)?;
        let edges = all_edges_2d(&mesh, &shapes)?;
        let boundary = Features::extract(&mesh, &shapes, Some(&edges), None, Extract::Boundary)?;
        let find = Find::new(&mesh, &boundary)?;
        assert_eq!(find.points(At::Z(0.0)).err(), Some("At::Z works in 3D only"));
        assert_eq!(find.points(At::YZ(0.0, 0.0)).err(), Some("At::YZ works in 3D only"));
        assert_eq!(find.points(At::XZ(0.0, 0.0)).err(), Some("At::XZ works in 3D only"));
        assert_eq!(
            find.points(At::XYZ(0.0, 0.0, 0.0)).err(),
            Some("At::XYZ works in 3D only")
        );
        assert_eq!(
            find.points(At::Cylinder(0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0)).err(),
            Some("At::Cylinder works in 3D only")
        );

        // 3d
        let mesh = Samples::two_cubes_vertical();
        let shapes = allocate_shapes(&mesh)?;
        let faces = all_faces_3d(&mesh, &shapes)?;
        let boundary = Features::extract(&mesh, &shapes, None, Some(&faces), Extract::Boundary)?;
        let find = Find::new(&mesh, &boundary)?;
        assert_eq!(
            find.points(At::Circle(0.0, 0.0, 0.0)).err(),
            Some("At::Circle works in 2D only")
        );
        Ok(())
    }

    fn check<T>(found: &HashSet<T>, correct: &[T])
    where
        T: Copy + Ord + std::fmt::Debug,
    {
        let mut ids: Vec<T> = found.iter().copied().collect();
        ids.sort();
        assert_eq!(ids, correct);
    }

    #[test]
    fn find_points_works_2d() -> Result<(), StrError> {
        // `.       `.
        //   3--------2--------5
        //   | `.     | `.     |
        //   |   `~.  | circle |
        //   |      `.|        |
        //   0--------1--------4
        //           circle
        let mesh = Samples::two_quads_horizontal();
        let shapes = allocate_shapes(&mesh)?;
        let edges = all_edges_2d(&mesh, &shapes)?;
        let boundary = Features::extract(&mesh, &shapes, Some(&edges), None, Extract::Boundary)?;
        let find = Find::new(&mesh, &boundary)?;
        check(&find.points(At::XY(0.0, 0.0))?, &[0]);
        check(&find.points(At::XY(2.0, 1.0))?, &[5]);
        assert_eq!(
            find.points(At::XY(10.0, 0.0)).err(),
            Some("cannot find point with coordinates outside the grid")
        );
        check(&find.points(At::Circle(0.0, 0.0, 1.0))?, &[1, 3]);
        check(&find.points(At::Circle(0.0, 0.0, SQRT_2))?, &[2]);
        check(&find.points(At::Circle(0.0, 0.0, 10.0))?, &[]);
        Ok(())
    }

    #[test]
    fn find_points_works_3d() -> Result<(), StrError> {
        //      8-----------11  2.0
        //     /.           /|
        //    / .          / |
        //   /  .         /  |
        //  9-----------10   |
        //  |   .        |   |
        //  |   4--------|---7  1.0
        //  |  /.        |  /|
        //  | / .        | / |
        //  |/  .        |/  |
        //  5------------6   |          z
        //  |   .        |   |          ↑
        //  |   0--------|---3  0.0     o → y
        //  |  /         |  /          ↙
        //  | /          | /          x
        //  |/           |/
        //  1------------2   1.0
        // 0.0          1.0
        let mesh = Samples::two_cubes_vertical();
        let shapes = allocate_shapes(&mesh)?;
        let faces = all_faces_3d(&mesh, &shapes)?;
        let boundary = Features::extract(&mesh, &shapes, None, Some(&faces), Extract::Boundary)?;
        let find = Find::new(&mesh, &boundary)?;
        // plot_grid_two_cubes_vertical(&find)?;
        check(&find.points(At::X(0.0))?, &[0, 3, 4, 7, 8, 11]);
        check(&find.points(At::X(1.0))?, &[1, 2, 5, 6, 9, 10]);
        check(&find.points(At::X(10.0))?, &[]);
        check(&find.points(At::Y(0.0))?, &[0, 1, 4, 5, 8, 9]);
        check(&find.points(At::Y(1.0))?, &[2, 3, 6, 7, 10, 11]);
        check(&find.points(At::Y(10.0))?, &[]);
        check(&find.points(At::Z(0.0))?, &[0, 1, 2, 3]);
        check(&find.points(At::Z(1.0))?, &[4, 5, 6, 7]);
        check(&find.points(At::Z(2.0))?, &[8, 9, 10, 11]);
        check(&find.points(At::Z(10.0))?, &[]);
        check(&find.points(At::XY(0.0, 0.0))?, &[0, 4, 8]);
        check(&find.points(At::XY(1.0, 1.0))?, &[2, 6, 10]);
        check(&find.points(At::XY(10.0, 10.0))?, &[]);
        check(&find.points(At::YZ(0.0, 0.0))?, &[0, 1]);
        check(&find.points(At::YZ(1.0, 1.0))?, &[6, 7]);
        check(&find.points(At::XZ(0.0, 0.0))?, &[0, 3]);
        check(&find.points(At::XZ(1.0, 0.0))?, &[1, 2]);
        check(&find.points(At::XZ(1.0, 2.0))?, &[9, 10]);
        check(&find.points(At::XYZ(0.0, 0.0, 0.0))?, &[0]);
        check(&find.points(At::XYZ(1.0, 1.0, 2.0))?, &[10]);
        assert_eq!(
            find.points(At::XYZ(10.0, 0.0, 0.0)).err(),
            Some("cannot find point with coordinates outside the grid")
        );
        check(
            &find.points(At::Cylinder(0.0, 0.0, 0.0, 0.0, 0.0, 2.0, 1.0))?,
            &[1, 3, 5, 7, 9, 11],
        );
        check(
            &find.points(At::Cylinder(0.0, 0.0, 0.0, 0.0, 0.0, 2.0, SQRT_2))?,
            &[2, 6, 10],
        );
        check(&find.points(At::Cylinder(0.0, 0.0, 0.0, 0.0, 0.0, 2.0, 10.0))?, &[]);
        Ok(())
    }

    #[test]
    fn find_edges_works_2d() -> Result<(), StrError> {
        // 3--------2--------5
        // |        |        |
        // |        |        |
        // |        |        |
        // 0--------1--------4
        let mesh = Samples::two_quads_horizontal();
        let shapes = allocate_shapes(&mesh)?;
        let edges = all_edges_2d(&mesh, &shapes)?;
        let boundary = Features::extract(&mesh, &shapes, Some(&edges), None, Extract::Boundary)?;
        let find = Find::new(&mesh, &boundary)?;
        check(&find.edges(At::Y(0.0))?, &[(0, 1), (1, 4)]);
        check(&find.edges(At::X(2.0))?, &[(4, 5)]);
        check(&find.edges(At::Y(1.0))?, &[(2, 3), (2, 5)]);
        check(&find.edges(At::X(0.0))?, &[(0, 3)]);
        check(&find.edges(At::X(1.0))?, &[]); // internal
        check(&find.edges(At::X(10.0))?, &[]); // far away
        Ok(())
    }

    #[test]
    fn find_edges_works_3d() -> Result<(), StrError> {
        //      8-----------11  2.0
        //     /.           /|
        //    / .          / |
        //   /  .         /  |
        //  9-----------10   |
        //  |   .        |   |
        //  |   4--------|---7  1.0
        //  |  /.        |  /|
        //  | / .        | / |
        //  |/  .        |/  |
        //  5------------6   |          z
        //  |   .        |   |          ↑
        //  |   0--------|---3  0.0     o → y
        //  |  /         |  /          ↙
        //  | /          | /          x
        //  |/           |/
        //  1------------2   1.0
        // 0.0          1.0
        let mesh = Samples::two_cubes_vertical();
        let shapes = allocate_shapes(&mesh)?;
        let faces = all_faces_3d(&mesh, &shapes)?;
        let boundary = Features::extract(&mesh, &shapes, None, Some(&faces), Extract::Boundary)?;
        let find = Find::new(&mesh, &boundary)?;
        check(
            &find.edges(At::X(0.0))?,
            &[(0, 3), (0, 4), (3, 7), (4, 7), (4, 8), (7, 11), (8, 11)],
        );
        check(
            &find.edges(At::X(1.0))?,
            &[(1, 2), (1, 5), (2, 6), (5, 6), (5, 9), (6, 10), (9, 10)],
        );
        check(&find.edges(At::X(10.0))?, &[]);
        check(
            &find.edges(At::Y(0.0))?,
            &[(0, 1), (0, 4), (1, 5), (4, 5), (4, 8), (5, 9), (8, 9)],
        );
        check(
            &find.edges(At::Y(1.0))?,
            &[(2, 3), (2, 6), (3, 7), (6, 7), (6, 10), (7, 11), (10, 11)],
        );
        check(&find.edges(At::Y(10.0))?, &[]);
        check(&find.edges(At::Z(0.0))?, &[(0, 1), (0, 3), (1, 2), (2, 3)]);
        check(&find.edges(At::Z(2.0))?, &[(8, 9), (8, 11), (9, 10), (10, 11)]);
        check(&find.edges(At::Z(10.0))?, &[]);
        check(&find.edges(At::XY(0.0, 0.0))?, &[(0, 4), (4, 8)]);
        check(&find.edges(At::XY(1.0, 1.0))?, &[(2, 6), (6, 10)]);
        check(&find.edges(At::XY(10.0, 10.0))?, &[]);
        check(&find.edges(At::YZ(0.0, 0.0))?, &[(0, 1)]);
        check(&find.edges(At::YZ(1.0, 1.0))?, &[(6, 7)]);
        check(&find.edges(At::YZ(10.0, 10.0))?, &[]);
        check(&find.edges(At::XZ(0.0, 0.0))?, &[(0, 3)]);
        check(&find.edges(At::XZ(1.0, 0.0))?, &[(1, 2)]);
        check(&find.edges(At::XZ(1.0, 2.0))?, &[(9, 10)]);
        check(&find.edges(At::XZ(10.0, 10.0))?, &[]);
        check(&find.edges(At::XYZ(0.0, 0.0, 0.0))?, &[]);
        assert_eq!(
            find.edges(At::XYZ(10.0, 0.0, 0.0)).err(),
            Some("cannot find point with coordinates outside the grid")
        );
        check(
            &find.edges(At::Cylinder(0.0, 0.0, 0.0, 0.0, 0.0, 2.0, 1.0))?,
            &[(1, 5), (3, 7), (5, 9), (7, 11)],
        );
        check(
            &find.edges(At::Cylinder(0.0, 0.0, 0.0, 0.0, 0.0, 2.0, SQRT_2))?,
            &[(2, 6), (6, 10)],
        );
        check(&find.edges(At::Cylinder(0.0, 0.0, 0.0, 0.0, 0.0, 2.0, 10.0))?, &[]);
        Ok(())
    }

    #[test]
    fn find_faces_returns_empty_in_2d() -> Result<(), StrError> {
        // 3--------2--------5
        // |        |        |
        // |        |        |
        // |        |        |
        // 0--------1--------4
        let mesh = Samples::two_quads_horizontal();
        let shapes = allocate_shapes(&mesh)?;
        let edges = all_edges_2d(&mesh, &shapes)?;
        let boundary = Features::extract(&mesh, &shapes, Some(&edges), None, Extract::Boundary)?;
        let find = Find::new(&mesh, &boundary)?;
        assert_eq!(find.faces(At::X(0.0))?.len(), 0);
        Ok(())
    }

    #[test]
    fn find_faces_works() -> Result<(), StrError> {
        //      8-----------11  2.0
        //     /.           /|
        //    / .          / |
        //   /  .         /  |
        //  9-----------10   |
        //  |   .        |   |
        //  |   4--------|---7  1.0
        //  |  /.        |  /|
        //  | / .        | / |
        //  |/  .        |/  |
        //  5------------6   |          z
        //  |   .        |   |          ↑
        //  |   0--------|---3  0.0     o → y
        //  |  /         |  /          ↙
        //  | /          | /          x
        //  |/           |/
        //  1------------2   1.0
        // 0.0          1.0
        let mesh = Samples::two_cubes_vertical();
        let shapes = allocate_shapes(&mesh)?;
        let faces = all_faces_3d(&mesh, &shapes)?;
        let boundary = Features::extract(&mesh, &shapes, None, Some(&faces), Extract::Boundary)?;
        let find = Find::new(&mesh, &boundary)?;
        check(&find.faces(At::X(0.0))?, &[(0, 3, 4, 7), (4, 7, 8, 11)]);
        check(&find.faces(At::X(1.0))?, &[(1, 2, 5, 6), (5, 6, 9, 10)]);
        check(&find.faces(At::X(10.0))?, &[]);
        check(&find.faces(At::Y(0.0))?, &[(0, 1, 4, 5), (4, 5, 8, 9)]);
        check(&find.faces(At::Y(1.0))?, &[(2, 3, 6, 7), (6, 7, 10, 11)]);
        check(&find.faces(At::Y(10.0))?, &[]);
        check(&find.faces(At::Z(0.0))?, &[(0, 1, 2, 3)]);
        check(&find.faces(At::Z(2.0))?, &[(8, 9, 10, 11)]);
        check(&find.faces(At::Z(10.0))?, &[]);
        check(&find.faces(At::XY(0.0, 0.0))?, &[]);
        check(&find.faces(At::XY(1.0, 1.0))?, &[]);
        check(&find.faces(At::XY(10.0, 10.0))?, &[]);
        check(&find.faces(At::YZ(0.0, 0.0))?, &[]);
        check(&find.faces(At::YZ(1.0, 1.0))?, &[]);
        check(&find.faces(At::YZ(10.0, 10.0))?, &[]);
        check(&find.faces(At::XZ(0.0, 0.0))?, &[]);
        check(&find.faces(At::XZ(1.0, 0.0))?, &[]);
        check(&find.faces(At::XZ(1.0, 2.0))?, &[]);
        check(&find.faces(At::XZ(10.0, 10.0))?, &[]);
        check(&find.faces(At::XYZ(0.0, 0.0, 0.0))?, &[]);
        assert_eq!(
            find.faces(At::XYZ(10.0, 0.0, 0.0)).err(),
            Some("cannot find point with coordinates outside the grid")
        );
        check(&find.faces(At::Cylinder(0.0, 0.0, 0.0, 0.0, 0.0, 2.0, 1.0))?, &[]);
        check(&find.faces(At::Cylinder(0.0, 0.0, 0.0, 0.0, 0.0, 2.0, SQRT_2))?, &[]);
        check(&find.faces(At::Cylinder(0.0, 0.0, 0.0, 0.0, 0.0, 2.0, 10.0))?, &[]);
        Ok(())
    }

    #[test]
    fn find_works_with_ring() -> Result<(), StrError> {
        // 2.0   14---36--,__11
        //        |          `,-..33
        // 1.75  24   [7]   22     `-,
        //        |         ,  [5]    ,8.
        // 1.5   13--35--10/        20   `*
        //        |       ,`*32    ,'      30
        // 1.25  23 [6] 21     *.7     [3]   *
        //        |     ,  [4]  , *.          5
        // 1.0   12-34-9      19    29     18' *
        //              `31. ,' [2]   *  _,     *
        //                  6.       _.4'        *
        //                   28  _.17   *   [1]  27
        //                     3'  [0]  26        *
        //                     25        *        *
        //        +             0---15---1---16---2
        //
        //                     1.0 1.25  1.5 1.75  2.0
        let mesh = Samples::ring_eight_qua8_rad1_thick1();
        let shapes = allocate_shapes(&mesh)?;
        let edges = all_edges_2d(&mesh, &shapes)?;
        let boundary = Features::extract(&mesh, &shapes, Some(&edges), None, Extract::Boundary)?;
        let find = Find::new(&mesh, &boundary)?;
        let (r, rr) = (1.0, 2.0);
        check(&find.points(At::XY(1.00, 0.00))?, &[0]);
        check(&find.points(At::XY(1.25, 0.00))?, &[15]);
        check(&find.points(At::XY(1.50, 0.00))?, &[1]);
        check(&find.points(At::XY(1.75, 0.00))?, &[16]);
        check(&find.points(At::XY(2.00, 0.00))?, &[2]);
        check(&find.points(At::XY(0.00, 1.00))?, &[12]);
        check(&find.points(At::XY(0.00, 1.25))?, &[23]);
        check(&find.points(At::XY(0.00, 1.75))?, &[24]);
        check(&find.points(At::XY(0.00, 1.50))?, &[13]);
        check(&find.points(At::XY(0.00, 2.00))?, &[14]);
        check(&find.points(At::XY(SQRT_2 / 2.0, SQRT_2 / 2.0))?, &[6]);
        check(&find.points(At::XY(SQRT_2, SQRT_2))?, &[8]);
        check(
            &find.points(At::Circle(0.0, 0.0, r))?,
            &[0, 3, 6, 9, 12, 25, 28, 31, 34],
        );
        check(
            &find.points(At::Circle(0.0, 0.0, rr))?,
            &[2, 5, 8, 11, 14, 27, 30, 33, 36],
        );
        check(&find.edges(At::Y(0.0))?, &[(0, 1), (1, 2)]);
        check(&find.edges(At::X(0.0))?, &[(12, 13), (13, 14)]);
        check(
            &find.edges(At::Circle(0.0, 0.0, r))?,
            &[(0, 3), (3, 6), (6, 9), (9, 12)],
        );
        check(
            &find.edges(At::Circle(0.0, 0.0, rr))?,
            &[(2, 5), (5, 8), (8, 11), (11, 14)],
        );
        Ok(())
    }