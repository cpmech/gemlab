

// impl Features {
//     /// Extracts features (points, edges, faces)
//     ///
//     /// **Note:** The points of rods in 2D/3D or shells in 3D are only extracted with the All or Boundary options.
//     ///
//     /// # Input
//     ///
//     /// * `mesh` -- the Mesh
//     /// * `shapes` -- all shapes of cells (len == cells.len())
//     /// * `extract` -- option regarding what to extract (All and Boundary will extract points of rods and shells)
//     pub fn extract(mesh: &Mesh, shapes: &Vec<Shape>, extract: Extract) -> Result<Self, StrError> {
//         let mut features = match mesh.space_ndim {
//             2 => match edges {
//                 Some(edges) => extract_features_2d(mesh, shapes, &edges, &extract),
//                 None => return Err("edges map must be given in 2D"),
//             },
//             3 => match faces {
//                 Some(faces) => extract_features_3d(mesh, shapes, &faces, &extract),
//                 None => return Err("faces map must be given in 3D"),
//             },
//             _ => return Err("space_ndim must be 2 or 3"),
//         };
//         match extract {
//             Extract::All => extract_points_of_rods_or_shells(mesh, &mut features),
//             Extract::Boundary => extract_points_of_rods_or_shells(mesh, &mut features),
//             Extract::Interior => (),
//         }
//         Ok(features)
//     }
// }


///
/// # Examples
///
/// ## Two-dimensional
///
/// ```
/// use gemlab::mesh::{all_edges_2d, allocate_shapes, Cell, Extract, Features, Mesh, Point};
/// use gemlab::StrError;
///
/// fn main() -> Result<(), StrError> {
///     //  3---------2---------5
///     //  |         |         |
///     //  |   [0]   |   [1]   |
///     //  |         |         |
///     //  0---------1---------4
///     let mesh = Mesh {
///         space_ndim: 2,
///         points: vec![
///             Point { id: 0, coords: vec![0.0, 0.0] },
///             Point { id: 1, coords: vec![1.0, 0.0] },
///             Point { id: 2, coords: vec![1.0, 1.0] },
///             Point { id: 3, coords: vec![0.0, 1.0] },
///             Point { id: 4, coords: vec![2.0, 0.0] },
///             Point { id: 5, coords: vec![2.0, 1.0] },
///         ],
///         cells: vec![
///             Cell { id: 0, attribute_id: 1, geo_ndim: 2, points: vec![0, 1, 2, 3] },
///             Cell { id: 1, attribute_id: 2, geo_ndim: 2, points: vec![1, 4, 5, 2] },
///         ],
///     };
///
///     let shapes = allocate_shapes(&mesh)?;
///     let with_internal = false;
///     let edges = all_edges_2d(&mesh, &shapes)?;
///     let boundary = Features::extract(&mesh, &shapes, Some(&edges), None, Extract::Boundary)?;
///
///     let mut points: Vec<_> = boundary.points.iter().copied().collect();
///     points.sort();
///     assert_eq!(points, [0, 1, 2, 3, 4, 5]);
///
///     let mut edges: Vec<_> = boundary.edges.keys().copied().collect();
///     edges.sort();
///     assert_eq!(edges, [(0, 1), (0, 3), (1, 4), (2, 3), (2, 5), (4, 5)]);
///     Ok(())
/// }
/// ```
///
/// ## Three-dimensional
///
/// ```
/// use gemlab::mesh::{all_faces_3d, allocate_shapes, Cell, Extract, Features, Mesh, Point};
/// use gemlab::StrError;
///
/// fn main() -> Result<(), StrError> {
///     //          .4--------------7
///     //        ,' |            ,'|
///     //      ,'              ,'  |
///     //    ,'     |        ,'    |
///     //  5'==============6'      |
///     //  |               |       |
///     //  |        |      |       |
///     //  |       ,0- - - | - - - 3
///     //  |     ,'        |     ,'
///     //  |   ,'          |   ,'
///     //  | ,'            | ,'
///     //  1'--------------2'
///     let mesh = Mesh {
///         space_ndim: 3,
///         points: vec![
///             Point { id: 0, coords: vec![0.0, 0.0, 0.0] },
///             Point { id: 1, coords: vec![1.0, 0.0, 0.0] },
///             Point { id: 2, coords: vec![1.0, 1.0, 0.0] },
///             Point { id: 3, coords: vec![0.0, 1.0, 0.0] },
///             Point { id: 4, coords: vec![0.0, 0.0, 1.0] },
///             Point { id: 5, coords: vec![1.0, 0.0, 1.0] },
///             Point { id: 6, coords: vec![1.0, 1.0, 1.0] },
///             Point { id: 7, coords: vec![0.0, 1.0, 1.0] },
///         ],
///         cells: vec![
///             Cell { id: 0, attribute_id: 1, geo_ndim: 3, points: vec![0,1,2,3, 4,5,6,7] },
///         ],
///     };
///
///     let shapes = allocate_shapes(&mesh)?;
///     let faces = all_faces_3d(&mesh, &shapes)?;
///     let boundary = Features::extract(&mesh, &shapes, None, Some(&faces), Extract::Boundary)?;
///
///     let mut points: Vec<_> = boundary.points.iter().copied().collect();
///     points.sort();
///     assert_eq!(points, (0..8).collect::<Vec<_>>());
///
///     let mut edges: Vec<_> = boundary.edges.keys().copied().collect();
///     edges.sort();
///     assert_eq!(
///         edges,
///         [
///             (0, 1),
///             (0, 3),
///             (0, 4),
///             (1, 2),
///             (1, 5),
///             (2, 3),
///             (2, 6),
///             (3, 7),
///             (4, 5),
///             (4, 7),
///             (5, 6),
///             (6, 7)
///         ]
///     );
///
///     let mut faces: Vec<_> = boundary.faces.keys().copied().collect();
///     faces.sort();
///     assert_eq!(
///         faces,
///         [
///             (0, 1, 2, 3),
///             (0, 1, 4, 5),
///             (0, 3, 4, 7),
///             (1, 2, 5, 6),
///             (2, 3, 6, 7),
///             (4, 5, 6, 7),
///         ]
///     );
///     Ok(())
/// }
/// ```