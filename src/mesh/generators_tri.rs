use super::{Cell, Mesh, Point};
use crate::shapes::GeoKind;
use crate::StrError;
use russell_lab::math::PI;
use tritet::Trigen;

/// Groups generators of unstructured meshes (Tri and Tet only)
pub struct Unstructured {}

impl Unstructured {
    /// Generates a mesh representing a quarter of a ring in 2D
    ///
    /// ```text
    /// Geometry:
    ///
    /// y ^
    ///   |
    ///   ***=---__
    ///   |        '*._
    ///   |            *._
    ///   |               *.
    ///   ***=-__           *.
    ///   .      '-.          *
    ///             *.         *
    ///   .           *         *
    ///                *         *
    ///   .             *         *
    ///                 #         #
    ///   o -   -   -   # ------- # --> x
    ///               rmin       rmax
    /// ```
    ///
    /// ```text
    /// Point markers:
    ///
    /// -300 =---__
    ///   |        '*._
    ///   | -40        *._
    ///   |               *.  -20
    /// -400 =-__           *.
    ///          '-.          *
    ///             *.         *
    ///          -10  *         *
    ///                *         *
    ///                 *         *
    ///                 #   -30   #
    ///               -100 ----- -200
    /// ```
    ///
    /// # Input
    ///
    /// * `rmin` -- inner radius
    /// * `rmax` -- outer radius
    /// * `nr` -- number of divisions along the radius (must be > 0)
    /// * `na` -- number of divisions along alpha (must be > 0)
    /// * `o2` -- generate middle nodes
    /// * `global_max_area` -- max area allowed for all triangles
    /// * `trigen_vtu_filename` -- an optional filename for the VTU generated by trigen (may be "")
    pub fn quarter_ring_2d(
        rmin: f64,
        rmax: f64,
        nr: usize,
        na: usize,
        o2: bool,
        global_max_area: Option<f64>,
        trigen_vtu_filename: &str,
    ) -> Result<Mesh, StrError> {
        // check
        if nr < 1 {
            return Err("number of divisions along the radius must be > 0");
        }
        if na < 1 {
            return Err("number of divisions along alpha must be > 0");
        }

        // allocate data
        let npoint = 2 * (nr + 1) + 2 * (na - 1);
        let nsegment = npoint;
        let nregion = 1;
        let mut trigen = Trigen::new(npoint, Some(nsegment), Some(nregion), None)?;

        // constants
        const AMIN: f64 = 0.0;
        const AMAX: f64 = PI / 2.0;
        let dr = (rmax - rmin) / (nr as f64);
        let da = (AMAX - AMIN) / (na as f64);

        // counters
        let mut index = 0;

        // horizontal line
        trigen.set_point(index, -100, rmin, 0.0)?;
        index += 1;
        for i in 1..(nr + 1) {
            let marker = if i == nr { -200 } else { 0 };
            let r = rmin + (i as f64) * dr;
            trigen.set_point(index, marker, r, 0.0)?;
            trigen.set_segment(index - 1, -30, index - 1, index)?;
            index += 1;
        }

        // outer circle
        for i in 1..(na + 1) {
            let marker = if i == na { -300 } else { 0 };
            let a = AMIN + (i as f64) * da;
            let x = rmax * f64::cos(a);
            let y = rmax * f64::sin(a);
            trigen.set_point(index, marker, x, y)?;
            trigen.set_segment(index - 1, -20, index - 1, index)?;
            index += 1;
        }

        // vertical line
        for i in 1..(nr + 1) {
            let marker = if i == nr { -400 } else { 0 };
            let r = rmin + ((nr - i) as f64) * dr;
            trigen.set_point(index, marker, 0.0, r)?;
            trigen.set_segment(index - 1, -40, index - 1, index)?;
            index += 1;
        }

        // inner circle
        for i in 1..na {
            let a = AMIN + ((na - i) as f64) * da;
            let x = rmin * f64::cos(a);
            let y = rmin * f64::sin(a);
            trigen.set_point(index, 0, x, y)?;
            trigen.set_segment(index - 1, -10, index - 1, index)?;
            index += 1;
        }
        trigen.set_segment(index - 1, -10, index - 1, 0)?;

        // region
        trigen.set_region(0, 1, rmin + 1e-4, 1e-4, None)?;

        // generate mesh
        trigen.generate_mesh(false, o2, true, global_max_area, None)?;

        // write trigen vtu file
        if trigen_vtu_filename != "" {
            trigen.write_vtu(trigen_vtu_filename)?;
        }

        // allocate data
        const NDIM: usize = 2;
        let npoint = trigen.out_npoint();
        let ncell = trigen.out_ncell();
        let nnode = trigen.out_cell_npoint();
        let kind = if o2 { GeoKind::Tri6 } else { GeoKind::Tri3 };
        let zero_point = Point {
            id: 0,
            marker: 0,
            coords: vec![0.0; NDIM],
        };
        let zero_cell = Cell {
            id: 0,
            attribute: 1,
            kind,
            points: vec![0; nnode],
        };
        let mut mesh = Mesh {
            ndim: NDIM,
            points: vec![zero_point; npoint],
            cells: vec![zero_cell; ncell],
        };

        // set mesh data
        let mut points_on_inner_circle = Vec::new();
        let mut points_on_outer_circle = Vec::new();
        for i in 0..npoint {
            let marker = trigen.out_point_marker(i);
            if marker == -10 {
                points_on_inner_circle.push(i);
            }
            if marker == -20 {
                points_on_outer_circle.push(i);
            }
            mesh.points[i].id = i;
            mesh.points[i].marker = marker;
            mesh.points[i].coords[0] = trigen.out_point(i, 0);
            mesh.points[i].coords[1] = trigen.out_point(i, 1);
        }
        for i in 0..ncell {
            mesh.cells[i].id = i;
            mesh.cells[i].attribute = trigen.out_cell_attribute(i);
            for m in 0..nnode {
                mesh.cells[i].points[m] = trigen.out_cell_point(i, m);
            }
        }

        // -300 =---__
        //   |        '*._
        //   | -40        *._
        //   |               *.  -20
        // -400 =-__           *.
        //          '-.          *
        //             *.         *
        //          -10  *         *
        //                *         *
        //                 *         *
        //                 #   -30   #
        //               -100 ----- -200

        // apply constraints
        const TOL: f64 = 1e-15;
        for i in &points_on_inner_circle {
            let dx = mesh.points[*i].coords[0] - 0.0;
            let dy = mesh.points[*i].coords[1] - 0.0;
            let d = f64::sqrt(dx * dx + dy * dy);
            let gap = rmin - d;
            if f64::abs(gap) > TOL {
                let move_x = gap * dx / d;
                let move_y = gap * dy / d;
                mesh.points[*i].coords[0] += move_x;
                mesh.points[*i].coords[1] += move_y;
            }
        }
        for i in &points_on_outer_circle {
            let dx = mesh.points[*i].coords[0] - 0.0;
            let dy = mesh.points[*i].coords[1] - 0.0;
            let d = f64::sqrt(dx * dx + dy * dy);
            let gap = rmax - d;
            if f64::abs(gap) > TOL {
                let move_x = gap * dx / d;
                let move_y = gap * dy / d;
                mesh.points[*i].coords[0] += move_x;
                mesh.points[*i].coords[1] += move_y;
            }
        }

        // results
        Ok(mesh)
    }
}

////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////

#[cfg(test)]
mod tests {
    use super::Unstructured;
    use crate::geometry::point_point_distance;
    use crate::mesh::{check_all, check_overlapping_points};
    use russell_chk::approx_eq;

    #[allow(unused_imports)]
    use crate::mesh::draw_mesh;

    const SAVE_FIGURE: bool = false;

    fn filenames(fn_key: &str) -> (String, String, String) {
        let fn_trigen_vtu = if SAVE_FIGURE {
            [fn_key, "_trigen.vtu"].concat()
        } else {
            String::new()
        };
        let fn_vtu = [fn_key, ".vtu"].concat();
        let fn_svg = [fn_key, ".svg"].concat();
        (fn_trigen_vtu, fn_vtu, fn_svg)
    }

    #[test]
    fn tri_quarter_ring_2d_captures_errors() {
        assert_eq!(
            Unstructured::quarter_ring_2d(3.0, 6.0, 0, 4, false, None, "").err(),
            Some("number of divisions along the radius must be > 0")
        );
        assert_eq!(
            Unstructured::quarter_ring_2d(3.0, 6.0, 2, 0, false, None, "").err(),
            Some("number of divisions along alpha must be > 0")
        );
    }

    #[test]
    fn tri_quarter_ring_2d_works() {
        let (fn_trigen_vtu, fn_vtu, fn_svg) = filenames("/tmp/gemlab/test_tri_quarter_ring_2d");

        let mesh = Unstructured::quarter_ring_2d(3.0, 6.0, 2, 4, false, None, &fn_trigen_vtu).unwrap();

        if SAVE_FIGURE {
            draw_mesh(&mesh, false, true, false, &fn_svg).unwrap();
            mesh.write_vtu(&fn_vtu).unwrap();
        }

        assert_eq!(mesh.points.len(), 14);
        assert_eq!(mesh.cells.len(), 14);
        check_all(&mesh).unwrap();
        check_overlapping_points(&mesh, 0.18).unwrap();
        for p in [0, 11, 10, 9, 8] {
            let d = point_point_distance(&mesh.points[p].coords[0..2], &[0.0, 0.0]).unwrap();
            approx_eq(d, 3.0, 1e-15);
        }
        for p in [2, 3, 4, 5, 6] {
            let d = point_point_distance(&mesh.points[p].coords[0..2], &[0.0, 0.0]).unwrap();
            approx_eq(d, 6.0, 1e-15);
        }
    }

    #[test]
    fn tri_quarter_ring_2d_o2_works() {
        let (fn_trigen_vtu, fn_vtu, fn_svg) = filenames("/tmp/gemlab/test_tri_quarter_ring_2d_o2");

        let mesh = Unstructured::quarter_ring_2d(3.0, 6.0, 2, 4, true, None, &fn_trigen_vtu).unwrap();

        if SAVE_FIGURE {
            draw_mesh(&mesh, false, true, false, &fn_svg).unwrap();
            mesh.write_vtu(&fn_vtu).unwrap();
        }

        assert_eq!(mesh.points.len(), 41);
        assert_eq!(mesh.cells.len(), 14);
        check_all(&mesh).unwrap();
        check_overlapping_points(&mesh, 0.18).unwrap();
        for p in [0, 32, 11, 36, 10, 21, 9, 22, 8] {
            let d = point_point_distance(&mesh.points[p].coords[0..2], &[0.0, 0.0]).unwrap();
            approx_eq(d, 3.0, 1e-15);
        }
        for p in [2, 34, 3, 40, 4, 17, 5, 26, 6] {
            let d = point_point_distance(&mesh.points[p].coords[0..2], &[0.0, 0.0]).unwrap();
            approx_eq(d, 6.0, 1e-15);
        }
    }

    #[test]
    fn tri_quarter_ring_2d_global_max_area_works() {
        let (fn_trigen_vtu, fn_vtu, fn_svg) = filenames("/tmp/gemlab/test_tri_quarter_ring_2d_global_max_area");

        let global_max_area = Some(0.4);
        let mesh = Unstructured::quarter_ring_2d(3.0, 6.0, 2, 4, false, global_max_area, &fn_trigen_vtu).unwrap();

        if SAVE_FIGURE {
            draw_mesh(&mesh, false, true, false, &fn_svg).unwrap();
            mesh.write_vtu(&fn_vtu).unwrap();
        }

        // draw_mesh(&mesh, false, true, false, svg).unwrap();
        assert_eq!(mesh.points.len(), 50);
        assert_eq!(mesh.cells.len(), 78);
        check_all(&mesh).unwrap();
        check_overlapping_points(&mesh, 0.18).unwrap();
        for p in [0, 11, 10, 17, 9, 8] {
            let d = point_point_distance(&mesh.points[p].coords[0..2], &[0.0, 0.0]).unwrap();
            approx_eq(d, 3.0, 1e-15);
        }
        for p in [2, 40, 3, 25, 4, 24, 5, 33, 6] {
            let d = point_point_distance(&mesh.points[p].coords[0..2], &[0.0, 0.0]).unwrap();
            approx_eq(d, 6.0, 1e-15);
        }
    }

    #[test]
    fn tri_quarter_ring_2d_o2_global_max_area_works() {
        let (fn_trigen_vtu, fn_vtu, fn_svg) = filenames("/tmp/gemlab/test_tri_quarter_ring_2d_o2_global_max_area");

        let global_max_area = Some(0.4);
        let mesh = Unstructured::quarter_ring_2d(3.0, 6.0, 2, 4, true, global_max_area, &fn_trigen_vtu).unwrap();

        if SAVE_FIGURE {
            draw_mesh(&mesh, false, true, false, &fn_svg).unwrap();
            mesh.write_vtu(&fn_vtu).unwrap();
        }

        // draw_mesh(&mesh, false, true, false, svg).unwrap();
        assert_eq!(mesh.points.len(), 177);
        assert_eq!(mesh.cells.len(), 78);
        check_all(&mesh).unwrap();
        check_overlapping_points(&mesh, 0.1).unwrap();
        for p in [0, 150, 11, 81, 10, 58, 17, 99, 9, 146, 8] {
            let d = point_point_distance(&mesh.points[p].coords[0..2], &[0.0, 0.0]).unwrap();
            approx_eq(d, 3.0, 1e-15);
        }
        for p in [2, 154, 40, 176, 3, 174, 25, 130, 4, 118, 24, 136, 5, 124, 33, 134, 6] {
            let d = point_point_distance(&mesh.points[p].coords[0..2], &[0.0, 0.0]).unwrap();
            approx_eq(d, 6.0, 1e-15);
        }
    }
}
