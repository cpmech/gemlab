
///
/// # Examples
///
/// ## Two-dimensional
///
/// ```
/// use gemlab::mesh::{all_edges_2d, allocate_shapes, Cell, Extract, Features, Mesh, NormalVector, Point};
/// use gemlab::StrError;
///
/// fn main() -> Result<(), StrError> {
///     //  3---------2---------5
///     //  |         |         |
///     //  |   [0]   |   [1]   |
///     //  |         |         |
///     //  0---------1---------4
///     let mesh = Mesh {
///         space_ndim: 2,
///         points: vec![
///             Point { id: 0, coords: vec![0.0, 0.0] },
///             Point { id: 1, coords: vec![1.0, 0.0] },
///             Point { id: 2, coords: vec![1.0, 1.0] },
///             Point { id: 3, coords: vec![0.0, 1.0] },
///             Point { id: 4, coords: vec![2.0, 0.0] },
///             Point { id: 5, coords: vec![2.0, 1.0] },
///         ],
///         cells: vec![
///             Cell { id: 0, attribute_id: 1, geo_ndim: 2, points: vec![0, 1, 2, 3] },
///             Cell { id: 1, attribute_id: 2, geo_ndim: 2, points: vec![1, 4, 5, 2] },
///         ],
///     };
///
///     let shapes = allocate_shapes(&mesh)?;
///     let edges = all_edges_2d(&mesh, &shapes)?;
///     let boundary = Features::extract(&mesh, &shapes, Some(&edges), None, Extract::Boundary)?;
///
///     // the magnitude of the normal vector is equal to
///     // 0.5 = edge_length / 2.0 where 2.0 corresponds to
///     // the edge_length in the reference system
///
///     let mut normal = NormalVector::at_edge(&mesh, &boundary, (0, 1))?;
///     normal.evaluate(&[0.0, 0.0])?;
///     assert_eq!(normal.value.as_data(), &[0.0, -0.5]);
///
///     let mut normal = NormalVector::at_edge(&mesh, &boundary, (4, 5))?;
///     normal.evaluate(&[0.0, 0.0])?;
///     assert_eq!(normal.value.as_data(), &[0.5, 0.0]);
///
///     let mut normal = NormalVector::at_edge(&mesh, &boundary, (2, 5))?;
///     normal.evaluate(&[0.0, 0.0])?;
///     assert_eq!(normal.value.as_data(), &[0.0, 0.5]);
///
///     let mut normal = NormalVector::at_edge(&mesh, &boundary, (0, 3))?;
///     normal.evaluate(&[0.0, 0.0])?;
///     assert_eq!(normal.value.as_data(), &[-0.5, 0.0]);
///     Ok(())
/// }
/// ```
///
/// ## Three-dimensional
///
/// ```
/// use gemlab::mesh::{all_faces_3d, allocate_shapes, Cell, Extract, Features, Mesh, NormalVector, Point};
/// use gemlab::StrError;
///
/// fn main() -> Result<(), StrError> {
///     //          .4--------------7
///     //        ,' |            ,'|
///     //      ,'              ,'  |
///     //    ,'     |        ,'    |
///     //  5'==============6'      |
///     //  |               |       |
///     //  |        |      |       |
///     //  |       ,0- - - | - - - 3
///     //  |     ,'        |     ,'
///     //  |   ,'          |   ,'
///     //  | ,'            | ,'
///     //  1'--------------2'
///     let mesh = Mesh {
///         space_ndim: 3,
///         points: vec![
///             Point { id: 0, coords: vec![0.0, 0.0, 0.0] },
///             Point { id: 1, coords: vec![1.0, 0.0, 0.0] },
///             Point { id: 2, coords: vec![1.0, 1.0, 0.0] },
///             Point { id: 3, coords: vec![0.0, 1.0, 0.0] },
///             Point { id: 4, coords: vec![0.0, 0.0, 1.0] },
///             Point { id: 5, coords: vec![1.0, 0.0, 1.0] },
///             Point { id: 6, coords: vec![1.0, 1.0, 1.0] },
///             Point { id: 7, coords: vec![0.0, 1.0, 1.0] },
///         ],
///         cells: vec![
///             Cell { id: 0, attribute_id: 1, geo_ndim: 3, points: vec![0,1,2,3, 4,5,6,7] },
///         ],
///     };
///
///     let shapes = allocate_shapes(&mesh)?;
///     let faces = all_faces_3d(&mesh, &shapes)?;
///     let boundary = Features::extract(&mesh, &shapes, None, Some(&faces), Extract::Boundary)?;
///
///     // the magnitude of the normal vector is equal to
///     // 0.25 = face_area / 4.0 where 4.0 corresponds to
///     // the face_area in the reference system
///
///     let mut normal = NormalVector::at_face(&mesh, &boundary, (0, 3, 4, 7))?;
///     normal.evaluate(&[0.0, 0.0, 0.0])?;
///     assert_eq!(normal.value.as_data(), &[-0.25, 0.0, 0.0]);
///
///     let mut normal = NormalVector::at_face(&mesh, &boundary, (1, 2, 5, 6))?;
///     normal.evaluate(&[0.0, 0.0, 0.0])?;
///     assert_eq!(normal.value.as_data(), &[0.25, 0.0, 0.0]);
///
///     let mut normal = NormalVector::at_face(&mesh, &boundary, (0, 1, 4, 5))?;
///     normal.evaluate(&[0.0, 0.0, 0.0])?;
///     assert_eq!(normal.value.as_data(), &[0.0, -0.25, 0.0]);
///
///     let mut normal = NormalVector::at_face(&mesh, &boundary, (2, 3, 6, 7))?;
///     normal.evaluate(&[0.0, 0.0, 0.0])?;
///     assert_eq!(normal.value.as_data(), &[0.0, 0.25, 0.0]);
///
///     let mut normal = NormalVector::at_face(&mesh, &boundary, (0, 1, 2, 3))?;
///     normal.evaluate(&[0.0, 0.0, 0.0])?;
///     assert_eq!(normal.value.as_data(), &[0.0, 0.0, -0.25]);
///
///     let mut normal = NormalVector::at_face(&mesh, &boundary, (4, 5, 6, 7))?;
///     normal.evaluate(&[0.0, 0.0, 0.0])?;
///     assert_eq!(normal.value.as_data(), &[0.0, 0.0, 0.25]);
///     Ok(())
/// }
/// ```